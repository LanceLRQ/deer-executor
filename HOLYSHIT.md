踩坑记录：

2020-10-12
===
利用docker的reexec包执行自己后，发现时间判定和内存判定都较之前版本的有所偏差，一个hello_world.c的时间在4-5ms左右，内存大概要4MB。
初步怀疑是因为reexec是重新执行go程序，然后执行到其他分支去来模拟fork的，不是单纯的fork，故这边有所消耗。

尝试用一个文件，在syscall.Exec之前记录当前进程的rusage，后在判题机程序内减去，这种情况下内存基本正常，但是时间不稳定，
Mac下恒定在2ms，Linux下在0ms和4ms下反复横跳。说明这种修正方式是不正确的，getrusage不能准确的获取当前程序的执行时间。

决定：改回去用以前的那种fork形式了，这次改动的代码放在v2_dev_obsolete分支。

以前直接在协程里fork运行程序，计时那些是很准确的。但是在某些情况下会出现fork失败的情况，判题机频繁报SE，也许这个问题和go的协程有关，
具体是什么情况没能定位到。旧版内核是一个功能提供程序，常驻在内存里，要的时候go出个新的协程执行；新版判题机设计成独立运行，
每次需要的时候执行就行，用完直接退出，编译的时候再加上GOGC=off，以免go的gc搞事情。